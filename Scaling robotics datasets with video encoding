使用视频编码扩展机器人数据集

在过去的几年里，基于文本和图像的模型性能得到了显著提升，这主要归功于模型权重和数据集大小的扩展。虽然互联网为语言模型和图像生成模型提供了大量的文本和图像数据库，但机器人领域缺乏如此庞大和多样化的定性数据源以及高效的数据格式。尽管有像 Open X 这样的努力，我们仍然远远没有达到大型语言模型所看到的规模和多样性。此外，我们缺乏这项工作所需的工具，例如轻量级、快速加载、易于在线共享和可视化的数据集格式。这就是🤗 LeRobot 旨在解决的差距。

机器人数据集中的数据集是什么？

一般来说，至少在我们感兴趣的端到端学习框架中，机器人数据集通常有两种模态：视觉模态和机器人的本体感知 / 目标位置模态（状态 / 动作向量）。下面是它在实践中的样子：

到目前为止，存储视觉模态的最佳方式是为单个帧使用 PNG。这是非常冗余的，因为帧之间有很多重复。从业者不使用视频，因为加载时间可能会高出几个数量级。这些数据集通常以各种格式从学术论文中发布（hdf5、zarr、pickle、tar、zip……）。如今，现代视频编解码器可以实现令人印象深刻的压缩比 —— 意味着编码视频的大小与原始未压缩帧相比 —— 同时仍然保持出色的质量。这意味着，例如，压缩比为 1:20，即 5%（这很容易实现），你可以将一个 20GB 的数据集减少到 1GB 的数据。因此，我们决定使用视频编码来存储我们数据集的视觉模态。

贡献

我们提出了一种 LeRobotDataset 格式，它简单、轻量、易于共享（与中心有原生集成）且易于可视化。我们的数据集平均大小为其原始版本的 14%（在最佳情况下可达 0.2%），同时通过保持非常好的质量水平保留了对它们的完整训练能力。此外，我们观察到视频帧的解码时间遵循此模式，具体取决于分辨率： 

在我们解码单个帧的标称情况下，我们的加载时间与从压缩图像（png）加载帧的时间相当。

在我们解码多个连续帧的有利情况下，我们的加载时间是从压缩图像加载这些帧的 25%-50%。

除此之外，我们正在构建工具来轻松理解和浏览这些数据集。您可以使用我们的可视化工具在以下 Spaces 中自行探索一些示例（点击图像）：

但是什么是编解码器？视频编码和解码实际上在做什么？ 

从本质上讲，视频编码主要通过使用两个想法来减小视频的大小：

空间压缩：这与压缩图像（如 JPEG 或 PNG）中使用的原理相同。空间压缩利用图像的自相似性来减小其大小。例如，显示蓝色天空的视频的单个帧将具有大面积的相似颜色。空间压缩利用这一点来压缩这些区域，而不会在质量上损失太多。

时间压缩：时间压缩不是按原样存储每个帧（这会占用大量空间），而是计算每个帧之间的差异，并在编码视频流中仅保留这些差异（通常要小得多）。在解码时，通过将这些差异应用回去来重建每个帧。当然，这种方法需要至少一个参考帧来开始计算这些差异。但实际上，我们使用多个参考帧并定期放置。这有几个原因，在本文中有详细说明。这些 “参考帧” 称为关键帧或 I 帧（用于帧内编码帧）。

由于这两个想法，视频编码能够将视频的大小减小到可管理的程度。了解了这一点，编码过程大致如下：

根据用户的规格和场景变化确定关键帧。

对这些关键帧进行空间压缩。

然后对中间的帧进行时间压缩，作为 “差异”（也称为 P 帧或 B 帧，更多信息请参阅上面链接的文章）。

然后对这些差异本身进行空间压缩。

将来自 I 帧、P 帧和 B 帧的这些压缩数据编码为比特流。

然后将该视频比特流与可能的其他比特流（音频、字幕）和元数据一起打包到容器格式（MP4、MKV、AVI……）中。

此时，可能会应用额外的处理来减少压缩引起的任何视觉失真，并确保整个视频质量达到所需的标准。

显然，这是对正在发生的事情的高级概述，在这个过程中有很多移动部件和配置选择要做。从逻辑上讲，我们希望根据我们的需求和约束来评估最佳的实现方式，因此我们构建了一个基准来根据一些标准进行评估。

标准

虽然大小是我们决定使用视频编码的最初原因，但我们很快意识到还有其他方面需要考虑。当然，解码时间对于机器学习应用来说是一个重要的因素，因为我们希望最大限度地增加训练时间，而不是加载数据的时间。质量也需要保持在一定水平以上，以免降低我们策略的性能。最后，一个不太明显但同样重要的方面是我们编码视频的兼容性，以便能够在大多数媒体播放器、网络浏览器、设备等上轻松解码和播放。对我们来说，能够轻松快速地可视化任何数据集的内容是一个必备功能。

总之，这些是我们想要优化的标准：

大小：影响存储磁盘空间和下载时间。

解码时间：影响训练时间。

质量：影响训练精度。

兼容性：影响在不同设备和平台上轻松解码和可视化视频的能力。

显然，这些标准中的一些是直接矛盾的：例如，你很难在不降低质量的情况下减小文件大小，反之亦然。因此，目标是找到总体上的最佳妥协。

请注意，由于我们的具体用例和需求，一些传统上用于媒体消费的编码设置并不真正适用于我们。一个很好的例子是 GOP（图像组）大小。稍后会详细介绍。

指标

鉴于这些标准，我们相应地选择了指标。

大小压缩比（越低越好）：如前所述，这是编码视频的大小与原始未编码帧集的大小之比。

加载时间比（越低越好）：这是从视频解码给定帧所需的时间与从单个图像加载该帧所需的时间之比。

对于质量，我们查看了三个常用的指标：

平均均方误差（越低越好）：在所有请求的时间戳上，每个解码帧与其对应的原始图像之间的平均均方误差，并且还除以图像中的像素数，以便在不同图像大小之间进行比较。

平均峰值信噪比（越高越好）：测量信号的最大可能功率与影响其表示保真度的噪声功率之比。PSNR 越高表示质量越好。

平均结构相似性指数测量（越高越好）：通过比较亮度、对比度和结构来评估图像的感知质量。SSIM 值范围从 - 1 到 1，其中 1 表示完美相似。

此外，我们尝试了各种编码质量级别，以了解这些指标在视觉上的转化。然而，视频编码旨在吸引人类眼睛，利用人类视觉感知的几个原理，欺骗我们的大脑来保持一定的感知质量水平。这可能对神经网络产生不同的影响。因此，除了这些指标和视觉检查之外，通过 A/B 测试验证编码不会降低我们策略的性能对我们来说也很重要。

对于兼容性，我们本身没有一个指标，但它基本上归结为视频编解码器和像素格式。对于视频编解码器，我们选择的三个（h264、h265 和 AV1）是常见的，不会造成问题。然而，像素格式也很重要，我们后来发现，例如在大多数浏览器上，<beginning of the code>yuv444p<end of the code>不受支持，视频无法解码。

变量

图像内容和大小

我们不期望对于来自模拟、公寓中的真实世界、工厂、户外或场景中有许多移动对象等的图像数据集有相同的最优设置。同样，加载时间可能不会随图像大小（分辨率）线性变化。出于这些原因，我们在四个代表性数据集上运行了这个基准测试：

lerobot/pusht_image：（96 x 96 像素）具有简单几何形状的模拟，固定相机。

aliberts/aloha_mobile_shrimp_image：（480 x 640 像素）真实世界室内，移动相机。

aliberts/paris_street：（720 x 1280 像素）真实世界户外，移动相机。

aliberts/kitchen：（1080 x 1920 像素）真实世界室内，固定相机。


编码参数

我们使用 FFmpeg 对视频进行编码。以下是我们使用的主要参数：

视频编解码器（vcodec）

编解码器（编码器 - 解码器）是驱动视频编码的算法引擎。编解码器定义了用于编码和解码的格式。请注意，对于给定的编解码器，可能存在多种实现。例如对于 AV1：libaom（官方实现），libsvtav1（更快，仅编码器），libdav1d（仅解码器）。

请注意，其余的编码参数根据所使用的视频编解码器的不同而有不同的解释。换句话说，在一个编解码器中使用的相同 crf 值不一定在另一个编解码器中转化为相同的压缩级别。实际上，不同视频编解码器中的默认值（无）也不相同。重要的是，对于许多其他 ffmpeg 参数，如指定关键帧频率的 g 也是如此。 

像素格式

像素格式指定颜色空间（YUV、RGB、灰度），对于 YUV 颜色空间，还指定色度子采样，它决定了色度（颜色信息）和亮度（亮度信息）在最终编码比特流中的实际存储方式。例如，yuv420p表示具有 4:2:0 色度子采样的 YUV 颜色空间。这是网络视频和标准播放最常见的格式。对于 RGB 颜色空间，此参数指定每个像素的位数（例如rbg24表示具有 24 位每像素的 RGB 颜色空间）。

图像组大小

GOP（图像组）大小决定了关键帧在编码比特流中放置的频率。该值越低，关键帧放置的频率越高。需要理解的一个关键事项是，当在给定时间戳请求帧时，除非该帧恰好是关键帧本身，否则解码器将查找该时间戳之前的最后一个关键帧，并需要解码每个后续帧直到请求的时间戳。这意味着增加 GOP 大小将增加帧的平均解码时间，因为可用的关键帧更少。对于像 YouTube 上的视频或 Netflix 上的电影这样的典型在线内容，关键帧每 2 到 4 秒放置一次视频 —— 对于 24 fps 的视频，2 秒对应于 GOP 大小为 48—— 通常会转化为流畅的观看体验，因为这使得加载时间对于该用例来说是可以接受的（取决于硬件）。然而，对于训练策略，我们需要尽快访问任何帧，这意味着我们可能需要一个更低的 GOP 值。

恒定速率因素

恒定速率因子表示应用的有损压缩量。值为 0 表示不丢失任何信息，而高值（根据使用的编解码器，约为 50 - 60）非常有损。使用此参数而不是指定目标比特率更可取，因为它允许以潜在可变的比特率瞄准恒定的视觉质量水平，而不是相反。

此表总结了我们在研究中尝试的不同值：

parameter	values
vcodec	libx264, libx265, libsvtav1
pix_fmt	yuv444p, yuv420p
g	1, 2, 3, 4, 5, 6, 10, 15, 20, 40, None
crf	0, 5, 10, 15, 20, 25, 30, 40, 50, None

解码参数

解码器

我们测试了来自 torchvision 的两个视频解码后端：

• pyav（默认）

• video_reader

时间戳场景

鉴于视频解码的工作方式，一旦加载了关键帧，后续帧的解码速度就很快。这当然会受到编码期间的 -g 参数的影响，该参数指定了关键帧的频率。鉴于我们在机器人策略中的典型用例可能会在不同的随机位置请求几个时间戳，我们希望通过以下场景来复制这些用例： 

1_frame：1 帧，

• 2_frames：2 个连续帧（例如 [t, t + 1 / fps]），

• 6_frames：6 个连续帧（例如 [t + i / fps 对于 i 在范围(6)内]）

请注意，这与典型的用例（如观看电影）有很大不同，在观看电影中，每一帧都是从开头到结尾按顺序加载的，并且对于 -g 有较大的值是可以接受的。

此外，因为某些策略可能会请求相隔几个帧的单个时间戳，我们还有以下场景：

• 2_frames_4_space：2 帧，中间有 4 个连续帧的间隔（例如 [t, t + 5 / fps]），

然而，由于使用 pyav 实现视频解码的方式，我们无法进行精确的查找，因此在实践中，这种情况实际上与 6_frames 相同，因为在 t 和 t + 5 / fps 之间的所有 6 帧都将被解码。 

结果
在进行这项研究之后，我们从 v1.6 开始切换到了不同的编码。

恒定速率速率

由于使用了更兼容的 yuv420p 像素格式，我们借助 AV1 编码获得了更高的质量。

大小

在整个数据集大小范围内，我们实现了约 14%的平均压缩比。我们的大多数数据集都减少到了原始大小的 40%以下，有些甚至不到 1%。这些变化可归因于这些数据集来源的各种格式。压缩率最高的数据集通常包含未压缩的图像，使得编码器的时间和空间压缩能够大幅减小其大小。另一方面，图像已经使用某种形式的空间压缩（如 JPEG 或 PNG）存储的数据集在大小上的减少较少。其他因素，如图像分辨率，也会影响视频压缩的效果。

表 1：数据集大小比较 

加载时间

由于视频编码，我们的加载时间在分辨率方面的缩放效果要好得多。在我们解码多个连续帧的有利场景中尤其如此。

总结

我们研究的全部结果可在这个电子表格中获取。下面的表格展示了 g=2 和 crf=30 时的平均结果，使用后端=pyav 以及在所有时间戳模式（1 帧、2 帧、6 帧）下。

表 2：视频大小与图像大小的比率（越低越好）

表 3：视频和图像加载时间的比率（越低越好）

表 4：质量（均方误差：越低越好，峰值信噪比和结构相似性指数：越高越好） 

政策

我们验证了这种新格式不会对训练过的政策的性能产生影响，通过在我们的格式上训练其中一些政策。这些政策的性能与在图像版本上训练的那些相当。

图 1：在 pusht 数据集上的扩散政策的训练曲线

图 2：在 aloha 数据集上的 ACT 政策的训练曲线

政策也已经在 AV1 编码的数据集上进行了训练和评估，并与我们之前的参考（h264）进行了比较：

在 pusht 上的扩散：

• h264 编码运行

• AV1 编码运行

• 在 aloha_sim_transfer_cube_human 上的 ACT：

• h264 编码运行

• AV1 编码运行

• 在 aloha_sim_insertion_scripted 上的 ACT：

• h264 编码运行

• AV1 编码运行

未来工作

视频编码/解码是一个广泛而复杂的主题，我们在这里只是触及了表面。以下是我们在这个实验中遗留的一些事情：

对于编码，存在其他未包含在本次基准测试中的编码参数。特别是：

• -preset 允许选择编码预设。这代表了一组选项，将提供一定的编码速度与压缩比。如果未指定此参数，对于 libx264 和 libx265 它被认为是中等的，对于 libsvtav1 则是 8。

• -tune 允许针对某些方面（例如电影质量、直播等）优化编码。特别是，有一个快速解码选项可用于优化编码的比特流以实现更快的解码。

• 两次编码也值得研究，因为它会提高质量，尽管它可能会显著增加编码时间。请注意，由于我们主要对解码性能感兴趣（因为编码在上传数据集之前只进行一次），我们没有测量编码时间，也没有关于编码的任何指标。使用一次编码在本次基准测试中没有造成任何问题，并且没有花费大量时间（在使用 libsvtav1 而不是 libaom 进行 AV1 编码的情况下）。

 这些参数及其他参数更详细和全面的列表可在编解码器文档中获取：
 
• h264: https://trac.ffmpeg.org/wiki/Encode/H.264

• h265: https://trac.ffmpeg.org/wiki/Encode/H.265

• AV1: https://trac.ffmpeg.org/wiki/Encode/AV1

同样在解码方面，存在其他解码器，但在我们当前的基准测试中未实现。仅举几例：
• torchcodec

• torchaudio

• ffmpegio

• decord

• nvc

最后，我们尚未研究带有深度图的视频编码。尽管我们确实移植了包含深度图图像的数据集，但目前尚未使用该模式。 

译者：涂安鑫    2024/8/31
